//
//  Arboreal.swift
//  ObservablePlayground
//
//  Created by Gordon Brander on 11/7/23.
//

import SwiftUI
import Observation
import os

/// State is described with models.
/// A model is any type that knows how to update itself in response to actions.
/// Models can be value or reference types. It's typical to create
/// `@Observable` models.
public protocol ModelProtocol: AnyObject {
    associatedtype Action
    associatedtype Environment

    /// Update model in response to action, returning any side-effects (Fx).
    /// Update also receives an environment, which contains services it can
    /// use to produce side-effects.
    @MainActor func update(
        action: Action,
        environment: Environment
    ) -> Fx<Action>
}

extension ModelProtocol {
    /// Update model in response to a sequence of actions.
    /// Effects generated by update steps are combined and returned.
    /// - Parameters:
    ///   - actions: the sequence of actions to transact on the model
    ///   - environment: the environment
    /// - Returns: the combined Fx
    @MainActor public func update(
        actions: Array<Action>,
        environment: Environment
    ) -> Fx<Action> {
        var combinedFx = Fx<Action>()
        for action in actions {
            let fx = self.update(
                action: action,
                environment: environment
            )
            combinedFx.effects.append(contentsOf: fx.effects)
        }
        return combinedFx
    }
}

/// A transactable is any object that implements a `transact` method which can
/// receive actions and update itself. Stores are transactables.
public protocol TransactableProtocol {
    associatedtype Action

    func transact(_ action: Action)
}

extension TransactableProtocol {
    /// Send an action to the transactable.
    /// Ensures that mutation happens on the main actor.
    public func send(_ action: Action) {
        Task { @MainActor in
            self.transact(action)
        }
    }
}

/// Stores hold state and can receive actions via `send`.
public protocol StoreProtocol: TransactableProtocol {
    associatedtype Model: ModelProtocol where Model.Action == Action

    /// State should be get-only for stores.
    var state: Model { get }
}

/// Fx represents a collection of side-effects... things like http requests
/// or database calls that reference or mutate some outside resource.
///
/// Effects are modeled as async closures, which return an action representing
/// the result of the effect, for example, an HTTP response. Actions are
/// expected to model both success and failure cases.
///
/// Usage:
///
///     Fx {
///         let rows = environment.database.getPosts()
///         return rows.first
///     }
public struct Fx<Action> {
    /// No effects. Return this when your update function produces
    /// no side-effects.
    ///
    /// Usage:
    ///
    ///     func update(
    ///         action: Action,
    ///         environment: Environment
    ///     ) -> Fx<Action> {
    ///         return Fx.none
    ///     }
    public static var none: Self {
        Self()
    }
    
    /// An effect is an async thunk (zero-arg closure) that returns an Action.
    public typealias Effect = () async -> Action

    /// The batch of side-effects represented by this fx instance.
    public var effects: [Effect] = []
    
    /// Create an `Fx` with a single effect.
    public init(_ effect: @escaping Effect) {
        self.effects = [effect]
    }
    
    /// Create an `Fx` with an array of effects.
    public init(_ effects: [Effect] = []) {
        self.effects = effects
    }
    
    /// Merge two fx instances together.
    /// - Returns a new Fx containing the combined effects.
    public func merge(_ otherFx: Self) -> Self {
        var merged = self.effects
        merged.append(contentsOf: otherFx.effects)
        return Fx(merged)
    }

    /// Map effects, transforming their actions with `tag`.
    /// Used to map child component updates to parent context.
    ///
    /// Usage:
    ///
    ///     child
    ///         .update(action: action, environment: environment)
    ///         .tag(tagChild)
    ///
    /// - Returns a new Fx containing the tagged effects.
    public func tag<TaggedAction>(
        _ tag: @escaping (Action) -> TaggedAction
    ) -> Fx<TaggedAction> {
        Fx<TaggedAction>(
            effects.map({ effect in
                { await tag(effect()) }
            })
        )
    }
}

/// EffectRunner is an actor that runs all effects for a given store.
/// Effects are isolated to this actor, keeping them off the main thread, and
/// local to this effect runner.
actor EffectRunner<T: TransactableProtocol & AnyObject> {
    /// Transactable to notify when effect completes.
    /// We keep a weak reference to the transactable, since it is expected
    /// to hold a strong reference to this EffectRunner.
    private weak var subject: T?
    
    /// Create a new effect runner.
    /// - Parameters:
    ///   - subject: the transactable to send actions to
    public init(_ subject: T) {
        self.subject = subject
    }
    
    /// Run a batch of effects in parallel.
    /// Actions are sent to transactable in whatever order the tasks complete.
    public nonisolated func run(
        _ fx: Fx<T.Action>
    ) {
        for effect in fx.effects {
            Task {
                let action = await effect()
                await self.subject?.send(action)
            }
        }
    }
}

/// Store is a source of truth for application state.
///
/// Store hold a get-only `state` which conforms to `ModelProtocol` and knows
/// how to update itself and generate side-effects. All updates and effects
/// to this state happen through actions sent to `store.send`.
///
/// Store is `@Observable`, and can hold a state that is either a value-type
/// model, or a reference-type models that are also `@Observable`.
///
/// When using a hierarchy of observable `ModelProtocols` with Store,
/// it is strongly recommended that you mark all properties of your
/// models with `private(set)`, so that all updates are forced to go through
/// `Model.update(action:environment:)`. This ensures there is only one code
/// path that can modify state, making code more easily testable and reliable.
@Observable public final class Store<Model: ModelProtocol>: StoreProtocol {
    /// Turn logging on and off
    @ObservationIgnored var isLoggingEnabled: Bool
    /// Logger for store. You can customize this in the initializer.
    @ObservationIgnored var logger: Logger
    /// Runs all effects returned by model update function.
    @ObservationIgnored private lazy var runner = EffectRunner(self)
    /// Environment contains services that can be used by the update function
    /// to generate side effects such as DB queries or API calls.
    @ObservationIgnored public var environment: Model.Environment

    /// A read-only view of the current state.
    /// Nested models and other reference types should also mark their
    /// properties read-only. All state updates should go through
    /// `Model.update()`.
    public private(set) var state: Model

    /// Create a Store
    /// - Parameters:
    ///   - state: the initial state for the store. Must conform to
    ///     `ModelProtocol`.
    ///   - `environment`: an environment with services that can be used by the
    ///     model to generate side-effects such as DB queries or API calls.
    public init(
        state: Model,
        environment: Model.Environment,
        isLoggingEnabled: Bool = false,
        logger: Logger = Logger(
            subsystem: "Arboreal",
            category: "Store"
        )
    ) {
        self.state = state
        self.environment = environment
        self.isLoggingEnabled = isLoggingEnabled
        self.logger = logger
    }

    /// Create a store, sending an initail action
    public convenience init(
        state: Model,
        environment: Model.Environment,
        action: Model.Action,
        isLoggingEnabled: Bool = false,
        logger: Logger = Logger(
            subsystem: "Arboreal",
            category: "Store"
        )
    ) {
        self.init(
            state: state,
            environment: environment,
            isLoggingEnabled: isLoggingEnabled,
            logger: logger
        )
        self.send(action)
    }

    /// Send an action to store, updating state, and running effects.
    /// Calls the update method of the underlying model to update state and
    /// generate effects. Effects are run and the resulting actions are sent
    /// back into store, in whatever order the effects complete.
    /// Ensures that mutation happens on the main actor.
    @MainActor public func transact(_ action: Model.Action) {
        if isLoggingEnabled {
            let actionString = String(describing: action)
            logger.debug("Action: \(actionString, privacy: .public)")
        }
        let fx = state.update(
            action: action,
            environment: environment
        )
        runner.run(fx)
    }
}

/// Create a ViewStore that holds a reference to a model that is part of a
/// larger store.
///
/// Uses a closure to forward actions up to a parent store, which performs
/// the transaction and manages side-effects. ViewStores can be nested many
/// levels deep, and the actions forwarded up the chain until they are
/// received by the root store and the effects run.
public struct ViewStore<Model: ModelProtocol>: StoreProtocol {
    private var _transact: @MainActor (Model.Action) -> Void

    /// Get the current state from the underlying model.
    public private(set) var state: Model

    /// Initialize a ViewStore from a `get` closure and a `send` closure.
    /// These closures read from a parent store to provide a type-erased
    /// view over the store that only exposes domain-specific
    /// model and actions.
    public init(
        state: Model,
        transact: @escaping @MainActor (Model.Action) -> Void
    ) {
        self.state = state
        self._transact = transact
    }

    /// Send an action to the underlying store through ViewStore.
    @MainActor public func transact(_ action: Model.Action) {
        return self._transact(action)
    }
}

extension StoreProtocol {
    /// Create a viewStore from a store
    /// - Parameters:
    ///   - get: a closure or keypath to get the child model from the parent
    ///     store's model
    ///   - tag: a closure to tag a child action, making it a parent store
    ///     action
    /// - Returns: a ViewStore for the child model
    public func viewStore<ChildModel: ModelProtocol>(
        get: @escaping (Model) -> ChildModel,
        tag: @escaping (ChildModel.Action) -> Action
    ) -> ViewStore<ChildModel> {
        ViewStore(
            state: get(self.state),
            transact: { @MainActor action in self.transact(tag(action)) }
        )
    }
}

extension Binding {
    /// Create a `Binding` from a `StoreProtocol`.
    /// - Parameters:
    ///   - `store` is a reference to the store
    ///   - `get` reads the value from the state.
    ///   - `tag` tags the value, turning it into an action for `send`
    /// - Returns a binding suitable for use in a vanilla SwiftUI view.
    public init<Store: StoreProtocol>(
        store: Store,
        get: @escaping (Store.Model) -> Value,
        tag: @escaping (Value) -> Store.Model.Action
    ) {
        self.init(
            get: { get(store.state) },
            set: { value in
                store.transact(tag(value))
            }
        )
    }
}

extension StoreProtocol {
    /// Initialize a `Binding` from a `StoreProtocol`.
    /// - Parameters:
    ///   - `get` reads the value from the state.
    ///   - `tag` tags the value, turning it into an action for `send`
    /// - Returns a binding suitable for use in a vanilla SwiftUI view.
    public func binding<Value>(
        get: @escaping (Model) -> Value,
        tag: @escaping (Value) -> Action
    ) -> Binding<Value> {
        Binding(store: self, get: get, tag: tag)
    }
}
